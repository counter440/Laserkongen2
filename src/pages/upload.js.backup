import React, { useState, useRef, useEffect, useCallback, createContext, useContext } from 'react';
import Head from 'next/head';
import { FaUpload, FaCheck, FaSpinner, FaShoppingCart, FaCube } from 'react-icons/fa';
import { Canvas, useThree } from '@react-three/fiber';
import { OrbitControls } from '@react-three/drei';
import * as THREE from 'three';
import { STLLoader } from 'three/examples/jsm/loaders/STLLoader';
import ModelAnalysisPanel from '@/components/ModelAnalysisPanel';

// A shared context for model data
const ModelContext = createContext(null);

const useModelData = () => useContext(ModelContext);

const ModelProvider = ({ children, onModelAnalyzed }) => {
  const [modelData, setModelData] = useState(null);
  
  const analyzeModel = useCallback((geometry, options = {}) => {
    if (!geometry) return null;

    try {
      // Check if this is a large file needing special handling
      const isLargeFile = options?.isLargeFile || false;
      const fileSizeMB = options?.fileSizeMB || 0;
      
      // Compute bounding box for dimensions
      geometry.computeBoundingBox();
      const boundingBox = geometry.boundingBox;
      
      // Calculate dimensions in cm (assuming the model is in mm)
      const size = new THREE.Vector3();
      boundingBox.getSize(size);
      
      // Convert to cm by dividing by 10
      const dimensions = {
        x: parseFloat((size.x / 10).toFixed(2)),
        y: parseFloat((size.y / 10).toFixed(2)),
        z: parseFloat((size.z / 10).toFixed(2))
      };
    
    // Calculate volume - use a simplified approach to prevent freezing
    let volume = 0;
    
    // For large files or complex models, use a sampled approach to prevent browser freezing
    if (isLargeFile || fileSizeMB > 3 || 
        (geometry.attributes?.position && geometry.attributes.position.count > 100000)) {
      console.log('Using simplified volume calculation to prevent browser freezing');
      // Just use the bounding box with a reasonable fill factor 
      volume = dimensions.x * dimensions.y * dimensions.z * 0.3; // 30% of bounding box
    } 
    else if (geometry.isBufferGeometry) {
      try {
        // Get a sampling factor - only process a subset of triangles for very large models
        const positions = geometry.getAttribute('position').array;
        const indices = geometry.index ? geometry.index.array : null;
        
        // Detect model size and apply sampling to prevent browser freezing
        let samplingFactor = 1; // Process all triangles by default
        let triangleCount = indices ? indices.length / 3 : positions.length / 9;
        
        // Apply sampling for larger models
        if (triangleCount > 10000) samplingFactor = 5;   // Process 1 out of 5 triangles
        if (triangleCount > 20000) samplingFactor = 10;  // Process 1 out of 10 triangles
        if (triangleCount > 50000) samplingFactor = 20;  // Process 1 out of 20 triangles
        
        console.log(`Processing ${triangleCount} triangles with sampling factor ${samplingFactor}`);
        
        // Track progress and allow UI updates
        let processedCount = 0;
        let sampleVolume = 0;
        
        // Process sampled triangles - we'll multiply the result based on sampling
        if (indices) {
          for (let i = 0; i < indices.length; i += 3 * samplingFactor) {
            const i0 = indices[i] * 3;
            const i1 = indices[i + 1] * 3;
            const i2 = indices[i + 2] * 3;
            
            // Get the vertices of this triangle
            const x1 = positions[i0], y1 = positions[i0 + 1], z1 = positions[i0 + 2];
            const x2 = positions[i1], y2 = positions[i1 + 1], z2 = positions[i1 + 2];
            const x3 = positions[i2], y3 = positions[i2 + 1], z3 = positions[i2 + 2];
            
            // Calculate the signed volume contribution of this tetrahedron
            const tetraVolume = ((x1 * (y2 * z3 - y3 * z2) +
                                  x2 * (y3 * z1 - y1 * z3) +
                                  x3 * (y1 * z2 - y2 * z1)) / 6.0);
            
            sampleVolume += Math.abs(tetraVolume);
            processedCount++;
            
            // Allow UI updates every 5000 triangles
            if (processedCount % 5000 === 0) {
              console.log(`Processed ${processedCount} triangles...`);
            }
          }
          
          // Scale up the volume based on sampling
          volume = sampleVolume * samplingFactor;
        } else {
          for (let i = 0; i < positions.length; i += 9 * samplingFactor) {
            // Get the vertices of this triangle
            const x1 = positions[i], y1 = positions[i + 1], z1 = positions[i + 2];
            const x2 = positions[i + 3], y2 = positions[i + 4], z2 = positions[i + 5];
            const x3 = positions[i + 6], y3 = positions[i + 7], z3 = positions[i + 8];
            
            // Calculate the signed volume contribution of this tetrahedron
            const tetraVolume = ((x1 * (y2 * z3 - y3 * z2) +
                                  x2 * (y3 * z1 - y1 * z3) +
                                  x3 * (y1 * z2 - y2 * z1)) / 6.0);
            
            sampleVolume += Math.abs(tetraVolume);
            processedCount++;
            
            // Allow UI updates every 5000 triangles
            if (processedCount % 5000 === 0) {
              console.log(`Processed ${processedCount} triangles...`);
            }
          }
          
          // Scale up the volume based on sampling
          volume = sampleVolume * samplingFactor;
        }
      } catch (error) {
        console.error('Error calculating mesh volume:', error);
        // Fallback to bounding box approximation
        volume = dimensions.x * dimensions.y * dimensions.z * 0.3; // 30% of bounding box
      }
    } else {
      // Fallback to bounding box approximation
      volume = dimensions.x * dimensions.y * dimensions.z * 0.3; // 30% of bounding box
    }
    
    // Convert from mm³ to cm³ (dimensions already converted, so volume is still in mm³)
    volume = parseFloat((volume / 1000).toFixed(2)); // Accurate conversion from mm³ to cm³
    
    // Calculate weight based on volume and infill percentage
    // PLA density ~1.24 g/cm³, but we'll apply infill factor
    const density = 1.24;
    const infillFactor = 0.5; // Assume 50% infill as default
    const weight = parseFloat((volume * density * infillFactor).toFixed(2));
    
    // Calculate print time (rough estimation: 1 hour per 20g of filament)
    const printTime = parseFloat((weight / 20).toFixed(1));
    
    // Calculate triangle count for model complexity
    let triangleCount = 0;
    if (geometry.index) {
      triangleCount = geometry.index.count / 3;
    } else if (geometry.attributes && geometry.attributes.position) {
      triangleCount = geometry.attributes.position.count / 3;
    }
    
    // Add metadata to help with fallback/estimation if needed
    const data = {
      dimensions,
      volume,
      weight,
      printTime,
      triangleCount,
      isLargeFile
    };
    
    setModelData(data);
    if (onModelAnalyzed) {
      onModelAnalyzed(data);
    }
    
    return data;
    
    } catch (error) {
      console.error("Error in model analysis:", error);
      
      // Provide fallback data
      const fallbackDimension = options?.fileSizeMB ? Math.cbrt(options.fileSizeMB * 5) : 5;
      const fallbackVolume = options?.fileSizeMB ? options.fileSizeMB * 5 : 125;
      
      const fallbackData = {
        dimensions: {
          x: parseFloat(fallbackDimension.toFixed(2)),
          y: parseFloat(fallbackDimension.toFixed(2)),
          z: parseFloat(fallbackDimension.toFixed(2))
        },
        volume: parseFloat(fallbackVolume.toFixed(2)),
        weight: parseFloat((fallbackVolume * 1.24 * 0.5).toFixed(2)),
        printTime: parseFloat(((fallbackVolume * 1.24 * 0.5) / 20).toFixed(1)),
        isEstimated: true
      };
      
      setModelData(fallbackData);
      if (onModelAnalyzed) {
        onModelAnalyzed(fallbackData);
      }
      
      return fallbackData;
    }
  }, [onModelAnalyzed]);
  
  return (
    <ModelContext.Provider value={{ modelData, analyzeModel }}>
      {children}
    </ModelContext.Provider>
  );
};

// This is a component that loads and displays the 3D model
function Model({ url, onModelLoaded }) {
  const { scene } = useThree();
  const [model, setModel] = useState(null);
  const { analyzeModel } = useModelData();
  
  useEffect(() => {
    // Clear previous model from scene when URL changes
    if (model) {
      scene.remove(model);
      setModel(null);
    }
    
    if (!url) return;
    
    // Check if this is a large file that needs special handling
    const isLargeFile = url.includes("#large_file=true");
    
    // Extract file size from URL if available
    let fileSizeMB = 0;
    if (isLargeFile) {
      const sizeMatch = url.match(/size=([0-9.]+)/);
      if (sizeMatch && sizeMatch[1]) {
        fileSizeMB = parseFloat(sizeMatch[1]);
      }
    }
    
    // Get the actual URL without hash parameters
    const cleanUrl = url.split('#')[0];
    
    // Determine file extension
    const fileExtension = cleanUrl.split('.').pop().toLowerCase();
    
    // Create a placeholder mesh to show immediately while loading
    const placeholderGeometry = new THREE.BoxGeometry(1, 1, 1);
    const placeholderMaterial = new THREE.MeshStandardMaterial({ 
      color: 0x2196f3,
      transparent: true, 
      opacity: 0.5,
      wireframe: true
    });
    const placeholderMesh = new THREE.Mesh(placeholderGeometry, placeholderMaterial);
    placeholderMesh.castShadow = true;
    placeholderMesh.receiveShadow = true;
    
    scene.add(placeholderMesh);
    setModel(placeholderMesh);
    
    try {
      // Try to detect file type based on URL/BLOB
      if (cleanUrl.startsWith('blob:') || fileExtension === 'stl') {
        // Use STLLoader for STL files with try-catch for memory errors
        const loader = new STLLoader();
        
        // For large files, we'll use a simplified approach to avoid memory issues
        const loadOptions = isLargeFile ? { 
          // Add reduced memory footprint options (if STLLoader supported them)
        } : {};
        
        try {
          // Add a timeout to abort loading if it takes too long
          const abortController = new AbortController();
          const timeoutId = setTimeout(() => {
            abortController.abort();
            console.warn('STL loading timed out');
            
            // If loading timed out, use the placeholder and estimated data
            if (onModelLoaded) {
              // Generate fallback data based on file size
              const estimatedVolume = fileSizeMB * 8 * 0.3; // Conservative volume estimate
              const estimatedDimension = Math.cbrt(estimatedVolume);
              const fallbackData = {
                dimensions: {
                  x: parseFloat(estimatedDimension.toFixed(2)),
                  y: parseFloat(estimatedDimension.toFixed(2)),
                  z: parseFloat(estimatedDimension.toFixed(2))
                },
                volume: parseFloat(estimatedVolume.toFixed(2)),
                weight: parseFloat((estimatedVolume * 1.24 * 0.5).toFixed(2)),
                printTime: parseFloat(((estimatedVolume * 1.24 * 0.5) / 20).toFixed(1))
              };
              onModelLoaded(fallbackData);
            }
          }, isLargeFile ? 8000 : 20000); // 8 seconds for large files, 20 for regular ones
          
          // Attempt to load the model with strict memory protection
          const maxFaceCount = isLargeFile ? 50000 : 200000; // Much stricter limits
          
          // Configure abort controller based on file size for better performance with large files
          const makeAbortHandler = () => {
            console.warn('Aborting STL load due to timeout or file size');
            if (onModelLoaded) {
              // Scale volume estimate based on file size - larger files tend to have more empty space
              const volumeScaleFactor = fileSizeMB > 30 ? 0.15 : fileSizeMB > 20 ? 0.2 : 0.3;
              const estimatedVolume = fileSizeMB * 8; // Estimate based on file size
              const estDimension = Math.cbrt(estimatedVolume);
                
              const fallbackData = {
                dimensions: {
                  x: parseFloat(estDimension.toFixed(2)),
                  y: parseFloat(estDimension.toFixed(2)),
                  z: parseFloat(estDimension.toFixed(2))
                },
                volume: parseFloat((estimatedVolume * volumeScaleFactor).toFixed(2)),
                weight: parseFloat((estimatedVolume * volumeScaleFactor * 1.24 * 0.5).toFixed(2)),
                printTime: parseFloat(((estimatedVolume * volumeScaleFactor * 1.24 * 0.5) / 20).toFixed(1)),
                isEstimated: true,
                fileSize: fileSizeMB
              };
              onModelLoaded(fallbackData);
            }
          };
          
          abortController.abort = makeAbortHandler;
            
          // For extremely large files (> 25MB), use simplified loading approach
          if (fileSizeMB > 25) {
            console.log("Very large file detected, using simplified loading approach");
            // We'll still try to load but with stricter limits and timeout
            timeoutId = setTimeout(() => {
              abortController.abort();
            }, 5000); // Short timeout for massive files
          }
          
          loader.load(
            cleanUrl,
            (geometry) => {
              clearTimeout(timeoutId); // Clear the timeout
              
              try {
                // For very large geometries, use a very simplified approach
                const faceCount = geometry.attributes?.position ? geometry.attributes.position.count / 3 : 0;
                
                console.log(`Loaded geometry with ${faceCount} faces`);
                
                // If the model is too large, use a simple box instead with estimated dimensions
                if (faceCount > maxFaceCount) {
                  console.log(`Geometry too large (${faceCount} faces), using simple approximation`);
                  
                  // Use bounding box for dimensions but create a simple box for display
                  geometry.computeBoundingBox();
                  const boundingBox = geometry.boundingBox;
                  const size = new THREE.Vector3();
                  boundingBox.getSize(size);
                  
                  // Create a simple box with the same dimensions
                  const boxGeometry = new THREE.BoxGeometry(size.x, size.y, size.z);
                  
                  // Update the reference to use the simplified geometry
                  geometry = boxGeometry;
                }
                
                // Analyze the geometry and get actual model data
                // We pass the file size to help with large file estimation
                const modelData = analyzeModel(geometry, { isLargeFile, fileSizeMB });
                
                const material = new THREE.MeshStandardMaterial({ 
                  color: 0x2196f3,
                  roughness: 0.5,
                  metalness: 0.2,
                  flatShading: isLargeFile // Use flat shading for large models to improve rendering performance
                });
                const mesh = new THREE.Mesh(processedGeometry, material);
                
                // Center the model by computing bounding box
                processedGeometry.computeBoundingBox();
                const boundingBox = processedGeometry.boundingBox;
                const center = new THREE.Vector3();
                boundingBox.getCenter(center);
                
                // First reset any existing transformations
                mesh.position.set(0, 0, 0);
                mesh.rotation.set(0, 0, 0);
                mesh.scale.set(1, 1, 1);
                
                // Create a proper geometry group to handle centering
                const group = new THREE.Group();
                group.add(mesh);
                
                // Step 1: Center the mesh
                mesh.position.set(-center.x, -center.y, -center.z);
                
                // Step 2: Get the size of the model
                const size = new THREE.Vector3();
                boundingBox.getSize(size);
                
                // Scale the model to a reasonable size
                const maxDim = Math.max(size.x, size.y, size.z);
                const scale = 2 / maxDim; // Smaller scale for better view
                group.scale.set(scale, scale, scale);
                
                // First apply the rotation
                group.rotation.x = -Math.PI / 2; // Rotate 90 degrees around X axis
                
                // IMPORTANT: Now after rotation we need to reposition
                // Add the group to scene temporarily so we can get correct world bounds
                scene.add(group);
                
                // Force update matrices to get proper bounding box in world space
                group.updateMatrixWorld(true);
                
                // Calculate world bounds
                const bbox = new THREE.Box3().setFromObject(mesh);
                
                // Position the group so the bottom of the mesh is at y=0
                group.position.y = -bbox.min.y;
                
                // Remove from scene (will be added properly later)
                scene.remove(group);
                
                // Set up shadows
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                
                // Replace the placeholder with the actual model
                scene.remove(placeholderMesh);
                scene.add(group);
                setModel(group);
                
                if (onModelLoaded) {
                  onModelLoaded(modelData);
                }
              } catch (geometryError) {
                console.error('Error processing STL geometry:', geometryError);
                
                // On error, keep using the placeholder but with a different color
                placeholderMaterial.color.set(0xf59e0b); // Amber color to indicate issue
                
                if (onModelLoaded) {
                  // Generate fallback data based on file size if available
                  const fallbackData = {
                    dimensions: { x: 5, y: 5, z: 5 },
                    volume: fileSizeMB ? fileSizeMB * 5 : 125,
                    weight: fileSizeMB ? fileSizeMB * 3 : 75,
                    printTime: fileSizeMB ? (fileSizeMB * 3) / 20 : 3.5
                  };
                  onModelLoaded(fallbackData);
                }
              }
            },
            (xhr) => {
              // Progress callback
              const percent = xhr.loaded / xhr.total * 100;
              console.log(`${percent.toFixed(1)}% loaded`);
              
              // Update placeholder color based on progress
              if (placeholderMesh && placeholderMesh.material) {
                // Gradually change color from blue to green as loading progresses
                const hue = 0.6 - (percent / 100 * 0.3); // 0.6 is blue, 0.3 is green in HSL
                placeholderMesh.material.color.setHSL(hue, 0.8, 0.5);
                placeholderMesh.material.opacity = 0.3 + (percent / 100 * 0.7);
              }
            },
            (error) => {
              clearTimeout(timeoutId); // Clear the timeout
              console.error('Error loading STL:', error);
              
              // Change placeholder to indicate error
              placeholderMaterial.color.set(0xff0000); // Red
              placeholderMaterial.opacity = 0.7;
              
              if (onModelLoaded) {
                // Generate fallback data based on file size if available
                const fallbackData = {
                  dimensions: { x: 5, y: 5, z: 5 },
                  volume: fileSizeMB ? fileSizeMB * 5 : 125,
                  weight: fileSizeMB ? fileSizeMB * 3 : 75,
                  printTime: fileSizeMB ? (fileSizeMB * 3) / 20 : 3.5
                };
                onModelLoaded(fallbackData);
              }
            }
          );
          
          // Return a cleanup function that will abort loading if component unmounts
          return () => {
            clearTimeout(timeoutId);
            if (abortController.abort) {
              abortController.abort();
            }
          };
        } catch (loaderError) {
          console.error('Exception in STL loader setup:', loaderError);
          
          // Keep using the placeholder but with error color
          placeholderMaterial.color.set(0xff0000); // Red
          
          // Generate fallback data
          if (onModelLoaded) {
            const fallbackData = {
              dimensions: { x: 5, y: 5, z: 5 },
              volume: fileSizeMB ? fileSizeMB * 5 : 125,
              weight: fileSizeMB ? fileSizeMB * 3 : 75,
              printTime: fileSizeMB ? (fileSizeMB * 3) / 20 : 3.5
            };
            onModelLoaded(fallbackData);
          }
        }
      } else if (fileExtension === 'obj') {
        console.log('OBJ file format detected - will add support soon');
        // Placeholder for OBJ support
        
        // Create a fallback for OBJ files
        const cubeGeometry = new THREE.BoxGeometry(1, 1, 1);
        const cubeMaterial = new THREE.MeshStandardMaterial({ 
          color: 0x2196f3,
          transparent: true, 
          opacity: 0.8
        });
        const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
        cube.castShadow = true;
        cube.receiveShadow = true;
        
        if (model) {
          scene.remove(model);
        }
        
        scene.add(cube);
        setModel(cube);
        
        if (onModelLoaded) {
          // Generate fallback data
          const fallbackData = {
            dimensions: { x: 5, y: 5, z: 5 },
            volume: 125,
            weight: 75,
            printTime: 3.5
          };
          onModelLoaded(fallbackData);
        }
        
      } else if (fileExtension === '3mf') {
        console.log('3MF file format detected - importing Three.js ThreeMFLoader');
        
        // We need to get the 3MFLoader directly from three-stdlib to avoid import issues
        import('three-stdlib').then(ThreeStdLib => {
          console.log('Three-stdlib imported successfully');
          const ThreeMFLoader = ThreeStdLib.ThreeMFLoader;
          
          try {
            console.log('Initializing ThreeMFLoader');
            const loader = new ThreeMFLoader();
            console.log('Loading 3MF file from URL:', url);
            
            loader.load(
              url,
              (object) => {
                console.log('3MF loaded successfully:', object);
                
                // Remove previous model if it exists
                if (model) {
                  scene.remove(model);
                }
                
                // Create a group to hold the loaded model
                const group = new THREE.Group();
                group.add(object);
                
                // Scale and position the model
                const bbox = new THREE.Box3().setFromObject(object);
                const size = new THREE.Vector3();
                bbox.getSize(size);
                
                console.log('Model dimensions:', size);
                
                // Calculate scale to make the model a reasonable size
                const maxDim = Math.max(size.x, size.y, size.z);
                const scale = 2 / maxDim;
                group.scale.set(scale, scale, scale);
                
                // Center the object
                const center = new THREE.Vector3();
                bbox.getCenter(center);
                object.position.set(-center.x, -center.y, -center.z);
                
                // Apply rotation to the group
                group.rotation.x = -Math.PI / 2;
                
                // Set up shadows
                object.traverse(child => {
                  if (child.isMesh) {
                    console.log('Processing mesh in 3MF:', child);
                    child.castShadow = true;
                    child.receiveShadow = true;
                    
                    // Update materials if needed
                    if (!child.material || !child.material.isMeshStandardMaterial) {
                      child.material = new THREE.MeshStandardMaterial({
                        color: (child.material && child.material.color) ? child.material.color : 0x2196f3,
                        roughness: 0.5,
                        metalness: 0.2
                      });
                    }
                  }
                });
                
                // Add to scene
                scene.add(group);
                setModel(group);
                
                // Generate model data
                // Since we can't directly compute volume from a Group,
                // we'll estimate based on bounding box
                const dimensions = {
                  x: parseFloat((size.x / 10).toFixed(2)),
                  y: parseFloat((size.y / 10).toFixed(2)), 
                  z: parseFloat((size.z / 10).toFixed(2))
                };
                
                const volume = parseFloat((dimensions.x * dimensions.y * dimensions.z).toFixed(2));
                const density = 1.24; // PLA density
                const infillFactor = 0.5; // 50% infill
                const weight = parseFloat((volume * density * infillFactor).toFixed(2));
                const printTime = parseFloat((weight / 20).toFixed(1));
                
                const modelData = {
                  dimensions,
                  volume,
                  weight,
                  printTime
                };
                
                console.log('3MF analysis complete:', modelData);
                
                if (onModelLoaded) {
                  onModelLoaded(modelData);
                }
              },
              (xhr) => {
                console.log(`3MF loading progress: ${(xhr.loaded / xhr.total * 100).toFixed(2)}%`);
              },
              (error) => {
                console.error('Error loading 3MF:', error);
                
                // Create a fallback cube on error
                const cubeGeometry = new THREE.BoxGeometry(1, 1, 1);
                const cubeMaterial = new THREE.MeshStandardMaterial({ 
                  color: 0x2196f3,
                  transparent: true, 
                  opacity: 0.8
                });
                const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
                cube.castShadow = true;
                cube.receiveShadow = true;
                
                if (model) {
                  scene.remove(model);
                }
                
                scene.add(cube);
                setModel(cube);
                
                if (onModelLoaded) {
                  // Generate fallback data
                  const fallbackData = {
                    dimensions: { x: 5, y: 5, z: 5 },
                    volume: 125,
                    weight: 75,
                    printTime: 3.5
                  };
                  onModelLoaded(fallbackData);
                }
              }
            );
          } catch (error) {
            console.error('Failed to initialize 3MF loader:', error);
            
            // Create a fallback cube
            const cubeGeometry = new THREE.BoxGeometry(1, 1, 1);
            const cubeMaterial = new THREE.MeshStandardMaterial({ 
              color: 0x2196f3,
              transparent: true, 
              opacity: 0.8
            });
            const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
            cube.castShadow = true;
            cube.receiveShadow = true;
            
            if (model) {
              scene.remove(model);
            }
            
            scene.add(cube);
            setModel(cube);
            
            if (onModelLoaded) {
              const fallbackData = {
                dimensions: { x: 5, y: 5, z: 5 },
                volume: 125,
                weight: 75,
                printTime: 3.5
              };
              onModelLoaded(fallbackData);
            }
          }
        }).catch(error => {
          console.error('Failed to import three-stdlib for 3MF loading:', error);
          
          // Create a fallback cube if module import fails
          const cubeGeometry = new THREE.BoxGeometry(1, 1, 1);
          const cubeMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x2196f3,
            transparent: true, 
            opacity: 0.8
          });
          const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
          cube.castShadow = true;
          cube.receiveShadow = true;
          
          if (model) {
            scene.remove(model);
          }
          
          scene.add(cube);
          setModel(cube);
          
          if (onModelLoaded) {
            const fallbackData = {
              dimensions: { x: 5, y: 5, z: 5 },
              volume: 125,
              weight: 75,
              printTime: 3.5
            };
            onModelLoaded(fallbackData);
          }
        });
      } else {
        console.warn('File format not explicitly supported, trying STL loader...');
        // Try STL loader as fallback
        const loader = new STLLoader();
        loader.load(url, 
          (geometry) => {
            // Process geometry as above...
            const modelData = analyzeModel(geometry);
            
            const material = new THREE.MeshStandardMaterial({ 
              color: 0x2196f3,
              roughness: 0.5,
              metalness: 0.2,
              flatShading: false
            });
            const mesh = new THREE.Mesh(geometry, material);
            
            // Center the model
            geometry.computeBoundingBox();
            const boundingBox = geometry.boundingBox;
            const center = new THREE.Vector3();
            boundingBox.getCenter(center);
            // Center the mesh completely
            mesh.position.set(-center.x, -center.y, -center.z);
            
            // Create a group for better positioning
            const group = new THREE.Group();
            group.add(mesh);
            
            // Scale the model to a reasonable size
            const maxDim = Math.max(size.x, size.y, size.z);
            const scale = 3 / maxDim; // Slightly smaller scale for better view
            group.scale.set(scale, scale, scale);
            
            // First apply the rotation
            group.rotation.x = -Math.PI / 2; // Rotate 90 degrees around X axis
            
            // IMPORTANT: Now after rotation we need to reposition
            // Add the group to scene temporarily so we can get correct world bounds
            scene.add(group);
            
            // Force update matrices to get proper bounding box in world space
            group.updateMatrixWorld(true);
            
            // Calculate world bounds
            const bbox = new THREE.Box3().setFromObject(mesh);
            
            // Position the group so the bottom of the mesh is at y=0
            group.position.y = -bbox.min.y;
            
            // Remove from scene (will be added properly later)
            scene.remove(group);
            
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            
            if (model) {
              scene.remove(model);
            }
            scene.add(group);
            setModel(group);
            
            if (onModelLoaded) {
              onModelLoaded(modelData);
            }
          }, 
          null, 
          (error) => {
            console.error('Error loading with fallback loader:', error);
          }
        );
      }
    } catch (error) {
      console.error('Exception during model loading:', error);
    }
    
    // Cleanup function
    return () => {
      if (model) {
        scene.remove(model);
      }
    };
  }, [url, scene, model, analyzeModel, onModelLoaded]);
  
  return null; // The model is added directly to the scene
}

export default function Upload({ cart, addToCart }) {
  const [file, setFile] = useState(null);
  const [modelData, setModelData] = useState(null);
  const [loading, setLoading] = useState(false);
  const [preview, setPreview] = useState(null);
  const [previewKey, setPreviewKey] = useState(0); // Used to force re-render of 3D preview
  const [activeTab, setActiveTab] = useState('3d-printing');
  const [selectedMaterial, setSelectedMaterial] = useState('pla');
  const [selectedColor, setSelectedColor] = useState('white');
  const [selectedQuality, setSelectedQuality] = useState('standard');
  const [selectedInfill, setSelectedInfill] = useState(20);
  const [additionalNotes, setAdditionalNotes] = useState('');
  const [quantity, setQuantity] = useState(1);
  const fileInputRef = useRef(null);
  
  // Simulated pricing calculations based on model data
  const materialPrices = {
    pla: 0.05, // per gram
    abs: 0.06,
    petg: 0.07,
    tpu: 0.09,
    nylon: 0.12,
  };
  
  const qualityMultipliers = {
    draft: 0.8,
    standard: 1.0,
    high: 1.3,
  };
  
  const infillMultiplier = (infill) => 0.7 + (infill / 100) * 0.6;
  
  // Handle model loaded callback from 3D viewer - with reduced operations to prevent freezing
  const handleModelLoaded = useCallback((data) => {
    if (data) {
      // We only need to do basic state updates - avoid any complex operations
      setModelData(data);
      setLoading(false);
      
      // Removed all localStorage and API operations to prevent potential freezing
      console.log("Model loaded and analyzed successfully");
    }
  }, []);

  const handleFileChange = (e) => {
    if (e.target.files.length === 0) return;
    
    const selectedFile = e.target.files[0];
    
    // Check file size with user-specified maximum limit of 50MB
    const fileSizeMB = selectedFile.size / (1024 * 1024);
    const maxSizeLimit = 50; // Maximum file size in MB
    const warningThreshold = 10; // Threshold for warning user
    const specialHandlingThreshold = 5; // Threshold for special processing approach
    
    if (fileSizeMB > maxSizeLimit) {
      alert(`Filstørrelsen overstiger ${maxSizeLimit}MB. Last opp en mindre fil.`);
      return;
    }
    
    // Add warning for large files that might affect performance
    if (fileSizeMB > warningThreshold) {
      const proceed = window.confirm(`Denne filen er ${fileSizeMB.toFixed(1)}MB og kan føre til tregere ytelse. For store filer vil vi bruke en forenklet beregningsmetode for å unngå nettleserproblemer. Vil du fortsette?`);
      if (!proceed) return;
    }
    
    // Flag file as large for special processing if it exceeds the threshold
    const isLargeFile = fileSizeMB > specialHandlingThreshold;
    
    // Clear previous data when loading a new file
    setModelData(null);
    setFile(selectedFile);
    
    // Increment the preview key to force re-render of 3D preview component
    setPreviewKey(prevKey => prevKey + 1);
    
    // Check file extension
    const fileName = selectedFile.name;
    const fileExtension = fileName.split('.').pop().toLowerCase();
    
    if (!['stl', 'obj'].includes(fileExtension)) {
      alert('Vennligst last opp et støttet 3D-filformat (STL, OBJ)');
      return;
    }
    
    // Start loading process
    setLoading(true);
    
    try {
      // Release previous preview URL if one exists
      if (preview) {
        URL.revokeObjectURL(preview);
      }
      
      // Create a preview URL for the file
      const previewUrl = URL.createObjectURL(selectedFile);
      setPreview(previewUrl);
      
      // Handle large files with special approach to prevent browser freezing
      if (isLargeFile) {
        console.log(`Large file detected (${fileSizeMB.toFixed(2)}MB), using optimized processing approach`);
        
        // Create special URL to signal the Model component to use simplified processing
        // We'll append parameters with hash to avoid changing the actual URL
        const largeFileUrl = previewUrl + '#large_file=true&size=' + fileSizeMB.toFixed(2);
        setPreview(largeFileUrl);
        
        // Create fallback data in case loading fails or takes too long
        const estimatedVolume = fileSizeMB * 8; // Estimate based on file size
        const estimatedDimension = Math.cbrt(estimatedVolume);
        
        // Scale volume estimate based on file size - larger files tend to have more empty space
        const volumeScaleFactor = fileSizeMB > 30 ? 0.15 : fileSizeMB > 20 ? 0.2 : 0.3;
        
        // Prepare fallback data with more accurate estimates for very large files
        const fallbackData = {
          dimensions: {
            x: parseFloat(estimatedDimension.toFixed(2)),
            y: parseFloat(estimatedDimension.toFixed(2)),
            z: parseFloat(estimatedDimension.toFixed(2))
          },
          volume: parseFloat((estimatedVolume * volumeScaleFactor).toFixed(2)),
          weight: parseFloat((estimatedVolume * volumeScaleFactor * 1.24 * 0.5).toFixed(2)),
          printTime: parseFloat(((estimatedVolume * volumeScaleFactor * 1.24 * 0.5) / 20).toFixed(1)),
          isEstimated: true,
          fileSize: fileSizeMB
        };
        
        // For extremely large files (>25MB), just use the fallback data immediately
        if (fileSizeMB > 25) {
          console.log("Extremely large file, using immediate fallback data");
          setTimeout(() => {
            setModelData(fallbackData);
            setLoading(false);
          }, 1500); // Short delay to show loading indicator
        } else {
          // For large but not extreme files, set a timeout as a fallback
          const fallbackTimer = setTimeout(() => {
            if (loading) { // Only use fallback if still loading
              console.log("Loading timeout reached, using fallback data");
              setModelData(fallbackData);
              setLoading(false);
            }
          }, fileSizeMB > 15 ? 5000 : 10000); // Shorter timeout for larger files
          
          // Store the timer ID for cleanup
          return () => clearTimeout(fallbackTimer);
        }
      }
      
      // For smaller files, we let the Model component handle analysis
      // The handleModelLoaded callback will be called when finished
      
      console.log('File loading initiated:', {
        fileName: selectedFile.name,
        fileType: selectedFile.type,
        fileExtension,
        fileSize: fileSizeMB.toFixed(2) + 'MB',
        isLargeFile: fileSizeMB > largeSizeThreshold
      });
    } catch (error) {
      console.error("Error in file processing:", error);
      setLoading(false);
      alert("Det oppsto en feil under behandling av filen din. Prøv en annen fil.");
    }
  };
  
  const calculatePrice = () => {
    if (!modelData) return 0;
    
    const materialCost = modelData.weight * materialPrices[selectedMaterial];
    const qualityCost = materialCost * qualityMultipliers[selectedQuality];
    const infillCost = qualityCost * infillMultiplier(selectedInfill);
    const timeCost = modelData.printTime * 5; // $5 per hour of printing
    
    const totalCost = infillCost + timeCost;
    return totalCost * quantity;
  };
  
  const handleAddToCart = () => {
    if (!modelData || !file) return;
    
    const customProduct = {
      id: 'custom-' + Date.now(),
      name: file.name.split('.')[0] || 'Tilpasset 3D-utskrift',
      price: calculatePrice(),
      customOptions: {
        type: activeTab,
        material: selectedMaterial,
        color: selectedColor,
        quality: selectedQuality,
        infill: selectedInfill,
        notes: additionalNotes,
        fileData: preview, // In a real app, you'd handle file storage differently
        modelData,
      },
      quantity: quantity,
    };
    
    addToCart(customProduct);
    alert('Lagt til i handlekurven!');
  };
  
  return (
    <div style={{ minHeight: '100vh', display: 'flex', flexDirection: 'column', fontFamily: 'system-ui, -apple-system, sans-serif' }}>
      <Head>
        <title>Last opp din design | Laserkongen</title>
        <meta name="description" content="Last opp din design for 3D-utskrift eller lasergravering og få et umiddelbart pristilbud." />
      </Head>
      
      <div style={{
        backgroundColor: 'white',
        boxShadow: '0 2px 4px rgba(0, 0, 0, 0.1)',
        padding: '0 24px',
        position: 'sticky',
        top: 0,
        zIndex: 100
      }}>
        <div style={{
          display: 'flex',
          justifyContent: 'space-between',
          alignItems: 'center',
          maxWidth: '1200px',
          margin: '0 auto',
          height: '70px'
        }}>
          <div style={{
            display: 'flex',
            alignItems: 'center',
            gap: '32px'
          }}>
            <a href="/" style={{
              fontSize: '22px',
              fontWeight: 'bold',
              color: '#0284c7',
              textDecoration: 'none'
            }}>LASERKONGEN</a>
            
            <nav style={{
              display: 'flex',
              gap: '24px'
            }}>
              <a href="/upload" style={{
                fontWeight: '500',
                color: '#0284c7',
                textDecoration: 'none',
                borderBottom: '2px solid #0284c7',
                paddingBottom: '4px'
              }}>Last opp design</a>
              
              <a href="/shop" style={{
                fontWeight: '500',
                color: '#4b5563',
                textDecoration: 'none',
                paddingBottom: '4px'
              }}>Butikk</a>
              
              <a href="/3d-printing" style={{
                fontWeight: '500',
                color: '#4b5563',
                textDecoration: 'none',
                paddingBottom: '4px'
              }}>3D-utskrift</a>
              
              <a href="/laser-engraving" style={{
                fontWeight: '500',
                color: '#4b5563',
                textDecoration: 'none',
                paddingBottom: '4px'
              }}>Lasergravering</a>
            </nav>
          </div>
          
          <div style={{
            display: 'flex',
            alignItems: 'center',
            gap: '16px'
          }}>
            <a href="/cart" style={{
              color: '#4b5563',
              textDecoration: 'none',
              position: 'relative'
            }}>
              <FaShoppingCart style={{ height: '20px', width: '20px' }} />
              {cart?.length > 0 && (
                <span style={{
                  position: 'absolute',
                  top: '-8px',
                  right: '-8px',
                  backgroundColor: '#0284c7',
                  color: 'white',
                  fontSize: '12px',
                  fontWeight: 'bold',
                  borderRadius: '50%',
                  height: '18px',
                  width: '18px',
                  display: 'flex',
                  alignItems: 'center',
                  justifyContent: 'center'
                }}>
                  {cart.length}
                </span>
              )}
            </a>
          </div>
        </div>
      </div>
      
      <div style={{ 
        background: 'linear-gradient(135deg, #0ea5e9 0%, #0284c7 100%)', 
        padding: '60px 24px', 
        color: 'white',
        textAlign: 'center'
      }}>
        <h1 style={{ 
          fontSize: '36px', 
          fontWeight: '800', 
          marginBottom: '16px',
          textShadow: '0 2px 4px rgba(0, 0, 0, 0.1)'
        }}>
          Gi liv til ideene dine
        </h1>
        <p style={{ 
          fontSize: '18px', 
          maxWidth: '800px', 
          margin: '0 auto 24px',
          opacity: '0.9'
        }}>
          Last opp din design og få et umiddelbart pristilbud. Vår avanserte kalkulator analyserer modellen din for å gi nøyaktig prissetting.
        </p>
      </div>
      
      <main style={{ flexGrow: 1, padding: '0', backgroundColor: '#f8fafc', marginTop: '-40px' }}>
        <div style={{ 
          maxWidth: '1200px', 
          margin: '0 auto',
          background: 'white',
          borderRadius: '12px',
          boxShadow: '0 10px 25px rgba(0, 0, 0, 0.05)',
          padding: '40px',
          position: 'relative'
        }}>
          
          {/* Service Type Tabs */}
          <div style={{ 
            display: 'flex', 
            borderBottom: '1px solid #e5e7eb', 
            marginBottom: '32px',
            justifyContent: 'center'
          }}>
            <button 
              style={{ 
                padding: '16px 32px', 
                fontWeight: '600',
                fontSize: '18px',
                color: activeTab === '3d-printing' ? '#0284c7' : '#6b7280',
                borderBottom: activeTab === '3d-printing' ? '3px solid #0284c7' : 'none',
                background: 'none',
                border: 'none',
                cursor: 'pointer',
                transition: 'all 0.2s ease'
              }}
              onClick={() => setActiveTab('3d-printing')}
            >
              3D-utskrift
            </button>
            <button 
              style={{ 
                padding: '16px 32px', 
                fontWeight: '600',
                fontSize: '18px',
                color: activeTab === 'laser-engraving' ? '#0284c7' : '#6b7280',
                borderBottom: activeTab === 'laser-engraving' ? '3px solid #0284c7' : 'none',
                background: 'none',
                border: 'none',
                cursor: 'pointer',
                transition: 'all 0.2s ease'
              }}
              onClick={() => setActiveTab('laser-engraving')}
            >
              Lasergravering
            </button>
          </div>
          
          <div style={{ display: 'grid', gridTemplateColumns: '1fr', gap: '40px' }}>
            {/* File Upload */}
            <div>
              <div style={{ 
                borderRadius: '12px', 
                padding: '30px', 
                marginBottom: '30px', 
                backgroundColor: 'white',
                boxShadow: '0 4px 12px rgba(0, 0, 0, 0.05)',
                border: '1px solid #e5e7eb'
              }}>
                <h2 style={{ 
                  fontSize: '22px', 
                  fontWeight: 'bold', 
                  marginBottom: '20px',
                  color: '#0ea5e9',
                  display: 'flex',
                  alignItems: 'center',
                  gap: '8px'
                }}>
                  <FaUpload style={{ height: '20px', width: '20px' }} />
                  Last opp din fil
                </h2>
                
                <div 
                  style={{ 
                    border: '2px dashed #d1d5db', 
                    borderRadius: '12px', 
                    padding: '40px', 
                    textAlign: 'center', 
                    cursor: 'pointer',
                    transition: 'all 0.3s ease',
                    background: '#f9fafb',
                    ':hover': {
                      borderColor: '#0ea5e9',
                      background: '#f0f9ff'
                    }
                  }}
                  onClick={() => fileInputRef.current?.click()}
                >
                  {!file ? (
                    <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center' }}>
                      <div style={{
                        background: 'linear-gradient(135deg, #0ea5e9 0%, #0284c7 100%)',
                        width: '80px',
                        height: '80px',
                        borderRadius: '50%',
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'center',
                        marginBottom: '24px',
                        boxShadow: '0 4px 12px rgba(2, 132, 199, 0.3)'
                      }}>
                        <FaUpload style={{ height: '32px', width: '32px', color: 'white' }} />
                      </div>
                      <p style={{ 
                        color: '#1f2937', 
                        marginBottom: '12px',
                        fontSize: '18px',
                        fontWeight: '500'
                      }}>Klikk eller dra for å laste opp filen din</p>
                      <p style={{ 
                        fontSize: '14px', 
                        color: '#6b7280',
                        padding: '8px 16px',
                        background: 'rgba(2, 132, 199, 0.05)',
                        borderRadius: '20px',
                        display: 'inline-block'
                      }}>
                        {activeTab === '3d-printing' 
                          ? 'Støttede formater: STL, OBJ (maks 50MB)' 
                          : 'Støttede formater: SVG, PNG, JPG (maks 20MB)'}
                      </p>
                    </div>
                  ) : (
                    <div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center' }}>
                      {loading ? (
                        <div style={{
                          background: 'linear-gradient(135deg, #0ea5e9 0%, #0284c7 100%)',
                          width: '80px',
                          height: '80px',
                          borderRadius: '50%',
                          display: 'flex',
                          alignItems: 'center',
                          justifyContent: 'center',
                          marginBottom: '24px',
                          boxShadow: '0 4px 12px rgba(2, 132, 199, 0.3)',
                          animation: 'spin 1s linear infinite'
                        }}>
                          <FaSpinner style={{ height: '32px', width: '32px', color: 'white' }} />
                        </div>
                      ) : (
                        <div style={{
                          background: 'linear-gradient(135deg, #22c55e 0%, #16a34a 100%)',
                          width: '80px',
                          height: '80px',
                          borderRadius: '50%',
                          display: 'flex',
                          alignItems: 'center',
                          justifyContent: 'center',
                          marginBottom: '24px',
                          boxShadow: '0 4px 12px rgba(22, 163, 74, 0.3)'
                        }}>
                          <FaCheck style={{ height: '32px', width: '32px', color: 'white' }} />
                        </div>
                      )}
                      <p style={{ 
                        color: '#1f2937', 
                        fontWeight: '500', 
                        marginBottom: '8px',
                        fontSize: '18px'
                      }}>{file.name}</p>
                      <p style={{ 
                        fontSize: '14px', 
                        color: '#6b7280',
                        padding: '4px 12px',
                        background: 'rgba(2, 132, 199, 0.05)',
                        borderRadius: '20px'
                      }}>{(file.size / (1024 * 1024)).toFixed(2)} MB</p>
                    </div>
                  )}
                  <input 
                    type="file" 
                    style={{ display: 'none' }}
                    ref={fileInputRef}
                    onChange={handleFileChange}
                    accept={activeTab === '3d-printing' ? '.stl,.obj' : '.svg,.png,.jpg,.jpeg'}
                  />
                </div>
              </div>
              
              {/* 3D Preview */}
              {activeTab === '3d-printing' && preview && (
                <div style={{ 
                  borderRadius: '12px', 
                  padding: '30px', 
                  marginBottom: '30px',
                  boxShadow: '0 4px 12px rgba(0, 0, 0, 0.05)',
                  border: '1px solid #e5e7eb',
                  backgroundColor: 'white'
                }}>
                  <h2 style={{ 
                    fontSize: '22px', 
                    fontWeight: 'bold', 
                    marginBottom: '20px',
                    color: '#0ea5e9',
                    display: 'flex',
                    alignItems: 'center',
                    gap: '8px'
                  }}>
                    <FaCube /> 3D-forhåndsvisning
                  </h2>
                  <div style={{ 
                    width: '100%', 
                    height: '300px', 
                    backgroundColor: '#f1f5f9', 
                    borderRadius: '8px', 
                    overflow: 'hidden',
                    boxShadow: 'inset 0 2px 4px rgba(0, 0, 0, 0.05)',
                    position: 'relative'
                  }}>
                    {/* Use the previewKey to force re-mount of the canvas when file changes */}
                    <ModelProvider key={`model-provider-${previewKey}`} onModelAnalyzed={handleModelLoaded}>
                      <Canvas 
                        key={`canvas-${previewKey}`}
                        camera={{ 
                          position: [5, 4, 5], 
                          fov: 35,
                          near: 0.1,
                          far: 1000
                        }}
                      >
                        <ambientLight intensity={0.5} />
                        <hemisphereLight intensity={0.5} color="#ffffff" groundColor="#bbbbbb" />
                        <directionalLight 
                          position={[5, 10, 5]} 
                          intensity={0.8} 
                          castShadow 
                          shadow-mapSize-width={1024} 
                          shadow-mapSize-height={1024}
                        />
                        <spotLight 
                          position={[-5, 10, 5]} 
                          angle={0.25} 
                          penumbra={0.8} 
                          intensity={0.6} 
                          castShadow 
                        />
                        <Model url={preview} onModelLoaded={handleModelLoaded} />
                        <OrbitControls 
                          enablePan={true} 
                          enableZoom={true} 
                          enableRotate={true}
                          target={[0, 0, 0]}
                          maxDistance={20}
                          minDistance={2}
                        />
                        <gridHelper args={[20, 20, '#bbbbbb', '#eeeeee']} position={[0, 0, 0]} rotation={[0, 0, 0]} />
                        <axesHelper args={[5]} visible={false} />
                      </Canvas>
                    </ModelProvider>
                    <div style={{
                      position: 'absolute',
                      bottom: '10px',
                      right: '10px',
                      backgroundColor: 'rgba(255, 255, 255, 0.7)',
                      padding: '5px 10px',
                      borderRadius: '4px',
                      fontSize: '12px',
                      color: '#4b5563'
                    }}>
                      Dra for å rotere | Scroll for å zoome
                    </div>
                  </div>
                </div>
              )}
              
              {/* 3D Model Analysis */}
              {activeTab === '3d-printing' && modelData && (
                <div style={{ 
                  borderRadius: '12px', 
                  padding: '30px',
                  marginBottom: '30px',
                  boxShadow: '0 4px 12px rgba(0, 0, 0, 0.05)',
                  border: '1px solid #e5e7eb',
                  backgroundColor: 'white'
                }}>
                  <h2 style={{ 
                    fontSize: '22px', 
                    fontWeight: 'bold', 
                    marginBottom: '20px',
                    color: '#0ea5e9',
                    display: 'flex',
                    alignItems: 'center',
                    gap: '8px'
                  }}>Modellanalyse</h2>
                  
                  <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '16px', marginBottom: '24px' }}>
                    <div style={{ 
                      padding: '16px', 
                      backgroundColor: '#f0f9ff', 
                      borderRadius: '8px',
                      display: 'flex',
                      flexDirection: 'column',
                      alignItems: 'center'
                    }}>
                      <span style={{ color: '#6b7280', fontSize: '14px', marginBottom: '4px' }}>Volum</span>
                      <span style={{ fontWeight: 'bold', fontSize: '24px', color: '#0ea5e9' }}>{modelData.volume} cm³</span>
                    </div>
                    
                    <div style={{ 
                      padding: '16px', 
                      backgroundColor: '#f0f9ff', 
                      borderRadius: '8px',
                      display: 'flex',
                      flexDirection: 'column',
                      alignItems: 'center'
                    }}>
                      <span style={{ color: '#6b7280', fontSize: '14px', marginBottom: '4px' }}>Vekt</span>
                      <span style={{ fontWeight: 'bold', fontSize: '24px', color: '#0ea5e9' }}>{modelData.weight} g</span>
                    </div>
                    
                    <div style={{ 
                      padding: '16px', 
                      backgroundColor: '#f0f9ff', 
                      borderRadius: '8px',
                      display: 'flex',
                      flexDirection: 'column',
                      alignItems: 'center'
                    }}>
                      <span style={{ color: '#6b7280', fontSize: '14px', marginBottom: '4px' }}>Dimensjoner</span>
                      <span style={{ fontWeight: 'bold', fontSize: '18px', color: '#0ea5e9' }}>
                        {modelData.dimensions.x} × {modelData.dimensions.y} × {modelData.dimensions.z} cm
                      </span>
                    </div>
                    
                    <div style={{ 
                      padding: '16px', 
                      backgroundColor: '#f0f9ff', 
                      borderRadius: '8px',
                      display: 'flex',
                      flexDirection: 'column',
                      alignItems: 'center'
                    }}>
                      <span style={{ color: '#6b7280', fontSize: '14px', marginBottom: '4px' }}>Utskriftstid</span>
                      <span style={{ fontWeight: 'bold', fontSize: '24px', color: '#0ea5e9' }}>{modelData.printTime} timer</span>
                    </div>
                  </div>
                  
                  <div>
                    <div style={{ marginBottom: '16px' }}>
                      <label style={{ display: 'block', fontWeight: '500', marginBottom: '8px', color: '#374151' }}>
                        Materiale
                      </label>
                      <select
                        value={selectedMaterial}
                        onChange={(e) => setSelectedMaterial(e.target.value)}
                        style={{
                          width: '100%',
                          padding: '12px',
                          borderRadius: '8px',
                          border: '1px solid #d1d5db',
                          fontSize: '16px'
                        }}
                      >
                        <option value="pla">PLA</option>
                        <option value="abs">ABS</option>
                        <option value="petg">PETG</option>
                        <option value="tpu">TPU (Flexible)</option>
                        <option value="nylon">Nylon</option>
                      </select>
                    </div>
                    
                    <div style={{ marginBottom: '16px' }}>
                      <label style={{ display: 'block', fontWeight: '500', marginBottom: '8px', color: '#374151' }}>
                        Utskriftskvalitet
                      </label>
                      <select
                        value={selectedQuality}
                        onChange={(e) => setSelectedQuality(e.target.value)}
                        style={{
                          width: '100%',
                          padding: '12px',
                          borderRadius: '8px',
                          border: '1px solid #d1d5db',
                          fontSize: '16px'
                        }}
                      >
                        <option value="draft">Utkast (0.3mm laghøyde)</option>
                        <option value="standard">Standard (0.2mm laghøyde)</option>
                        <option value="high">Høy (0.1mm laghøyde)</option>
                      </select>
                    </div>
                    
                    <div style={{ marginBottom: '16px' }}>
                      <label style={{ display: 'block', fontWeight: '500', marginBottom: '8px', color: '#374151' }}>
                        Fyllingsgrad: {selectedInfill}%
                      </label>
                      <input
                        type="range"
                        min="10"
                        max="100"
                        step="5"
                        value={selectedInfill}
                        onChange={(e) => setSelectedInfill(parseInt(e.target.value))}
                        style={{ width: '100%' }}
                      />
                      <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '14px', color: '#6b7280', marginTop: '4px' }}>
                        <span>10% (Lett)</span>
                        <span>100% (Solid)</span>
                      </div>
                    </div>
                  </div>
                </div>
              )}
              
              {/* Image Preview for Laser Engraving */}
              {activeTab === 'laser-engraving' && preview && (
                <div style={{ 
                  borderRadius: '12px', 
                  padding: '30px',
                  marginBottom: '30px',
                  boxShadow: '0 4px 12px rgba(0, 0, 0, 0.05)',
                  border: '1px solid #e5e7eb',
                  backgroundColor: 'white'
                }}>
                  <h2 style={{ 
                    fontSize: '22px', 
                    fontWeight: 'bold', 
                    marginBottom: '20px',
                    color: '#0ea5e9',
                    display: 'flex',
                    alignItems: 'center',
                    gap: '8px'
                  }}>Bildeforhåndsvisning</h2>
                  <div style={{ 
                    width: '100%', 
                    height: '300px', 
                    backgroundColor: '#f1f5f9', 
                    borderRadius: '8px', 
                    overflow: 'hidden',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    boxShadow: 'inset 0 2px 4px rgba(0, 0, 0, 0.05)'
                  }}>
                    <img src={preview} alt="Preview" style={{ maxWidth: '100%', maxHeight: '100%', objectFit: 'contain' }} />
                  </div>
                </div>
              )}
            </div>
            
            {/* Print Options and Pricing */}
            <div>
              <div style={{ 
                borderRadius: '12px', 
                padding: '30px', 
                marginBottom: '30px',
                boxShadow: '0 4px 12px rgba(0, 0, 0, 0.05)',
                border: '1px solid #e5e7eb',
                backgroundColor: 'white'
              }}>
                <h2 style={{ 
                  fontSize: '22px', 
                  fontWeight: 'bold', 
                  marginBottom: '20px',
                  color: '#0ea5e9',
                  display: 'flex',
                  alignItems: 'center',
                  gap: '8px'
                }}>
                  {activeTab === '3d-printing' ? '3D-utskriftsalternativer' : 'Lasergraveringsalternativer'}
                </h2>
                
                {activeTab === '3d-printing' && (
                  <div style={{ display: 'flex', flexDirection: 'column', gap: '20px' }}>
                    <div>
                      <label style={{ display: 'block', fontWeight: '500', marginBottom: '8px', color: '#374151' }} htmlFor="color">
                        Farge
                      </label>
                      <div style={{ display: 'flex', gap: '10px', flexWrap: 'wrap' }}>
                        {['white', 'black', 'gray', 'red', 'blue', 'green', 'yellow'].map(color => (
                          <div 
                            key={color}
                            onClick={() => setSelectedColor(color)}
                            style={{ 
                              width: '36px', 
                              height: '36px', 
                              borderRadius: '50%', 
                              backgroundColor: color === 'white' ? '#fff' : color,
                              border: selectedColor === color ? '3px solid #0ea5e9' : '1px solid #d1d5db',
                              cursor: 'pointer',
                              boxShadow: selectedColor === color ? '0 0 0 2px rgba(14, 165, 233, 0.2)' : 'none',
                              transition: 'all 0.2s ease'
                            }}
                          />
                        ))}
                      </div>
                      <p style={{ fontSize: '14px', color: '#6b7280', marginTop: '8px', textTransform: 'capitalize' }}>
                        Valgt: {selectedColor === 'white' ? 'hvit' : 
                               selectedColor === 'black' ? 'svart' : 
                               selectedColor === 'gray' ? 'grå' : 
                               selectedColor === 'red' ? 'rød' : 
                               selectedColor === 'blue' ? 'blå' : 
                               selectedColor === 'green' ? 'grønn' : 
                               selectedColor === 'yellow' ? 'gul' : selectedColor}
                      </p>
                    </div>
                  </div>
                )}
                
                {activeTab === 'laser-engraving' && (
                  <div style={{ display: 'flex', flexDirection: 'column', gap: '20px' }}>
                    <div>
                      <label style={{ display: 'block', fontWeight: '500', marginBottom: '8px', color: '#374151' }} htmlFor="material">
                        Materiale
                      </label>
                      <select
                        id="material"
                        value={selectedMaterial}
                        onChange={(e) => setSelectedMaterial(e.target.value)}
                        style={{
                          width: '100%',
                          padding: '12px',
                          borderRadius: '8px',
                          border: '1px solid #d1d5db',
                          fontSize: '16px'
                        }}
                      >
                        <option value="wood">Tre</option>
                        <option value="acrylic">Akryl</option>
                        <option value="leather">Lær</option>
                        <option value="glass">Glass</option>
                        <option value="metal">Metall</option>
                      </select>
                    </div>
                    
                    <div>
                      <label style={{ display: 'block', fontWeight: '500', marginBottom: '8px', color: '#374151' }} htmlFor="engravingType">
                        Graveringstype
                      </label>
                      <div style={{ display: 'flex', gap: '10px' }}>
                        {[
                          { value: 'draft', label: 'Kun omriss' },
                          { value: 'standard', label: 'Standard' },
                          { value: 'high', label: 'Dyp gravering' }
                        ].map(option => (
                          <button
                            key={option.value}
                            onClick={() => setSelectedQuality(option.value)}
                            style={{
                              flex: 1,
                              padding: '12px',
                              textAlign: 'center',
                              borderRadius: '8px',
                              border: '1px solid #d1d5db',
                              backgroundColor: selectedQuality === option.value ? '#0ea5e9' : 'white',
                              color: selectedQuality === option.value ? 'white' : '#374151',
                              fontWeight: selectedQuality === option.value ? '600' : '400',
                              cursor: 'pointer',
                              transition: 'all 0.2s ease'
                            }}
                          >
                            {option.label}
                          </button>
                        ))}
                      </div>
                    </div>
                    
                    <div>
                      <label style={{ display: 'block', fontWeight: '500', marginBottom: '8px', color: '#374151' }} htmlFor="size">
                        Størrelse (cm)
                      </label>
                      <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '16px' }}>
                        <input
                          type="number"
                          placeholder="Bredde"
                          style={{
                            width: '100%',
                            padding: '12px',
                            borderRadius: '8px',
                            border: '1px solid #d1d5db',
                            fontSize: '16px'
                          }}
                          min="1"
                          max="50"
                        />
                        <input
                          type="number"
                          placeholder="Høyde"
                          style={{
                            width: '100%',
                            padding: '12px',
                            borderRadius: '8px',
                            border: '1px solid #d1d5db',
                            fontSize: '16px'
                          }}
                          min="1"
                          max="50"
                        />
                      </div>
                    </div>
                  </div>
                )}
                
                <div style={{ marginTop: '24px' }}>
                  <label style={{ display: 'block', fontWeight: '500', marginBottom: '8px', color: '#374151' }} htmlFor="notes">
                    Tilleggsnotater
                  </label>
                  <textarea
                    id="notes"
                    rows="3"
                    style={{
                      width: '100%',
                      padding: '12px',
                      borderRadius: '8px',
                      border: '1px solid #d1d5db',
                      fontSize: '16px',
                      resize: 'vertical'
                    }}
                    placeholder="Spesielle instruksjoner for din bestilling..."
                    value={additionalNotes}
                    onChange={(e) => setAdditionalNotes(e.target.value)}
                  ></textarea>
                </div>
                
                <div style={{ marginTop: '24px' }}>
                  <label style={{ display: 'block', fontWeight: '500', marginBottom: '8px', color: '#374151' }} htmlFor="quantity">
                    Antall
                  </label>
                  <div style={{ display: 'flex', width: 'fit-content', alignItems: 'center' }}>
                    <button 
                      onClick={() => quantity > 1 && setQuantity(quantity - 1)}
                      style={{
                        width: '40px',
                        height: '40px',
                        borderRadius: '8px 0 0 8px',
                        border: '1px solid #d1d5db',
                        borderRight: 'none',
                        backgroundColor: '#f9fafb',
                        fontSize: '18px',
                        cursor: 'pointer',
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'center'
                      }}
                    >
                      -
                    </button>
                    <input
                      type="number"
                      id="quantity"
                      min="1"
                      max="100"
                      value={quantity}
                      onChange={(e) => setQuantity(parseInt(e.target.value))}
                      style={{
                        width: '60px',
                        height: '40px',
                        padding: '8px',
                        borderRadius: '0',
                        border: '1px solid #d1d5db',
                        textAlign: 'center',
                        fontSize: '16px'
                      }}
                    />
                    <button 
                      onClick={() => quantity < 100 && setQuantity(quantity + 1)}
                      style={{
                        width: '40px',
                        height: '40px',
                        borderRadius: '0 8px 8px 0',
                        border: '1px solid #d1d5db',
                        borderLeft: 'none',
                        backgroundColor: '#f9fafb',
                        fontSize: '18px',
                        cursor: 'pointer',
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'center'
                      }}
                    >
                      +
                    </button>
                  </div>
                </div>
              </div>
              
              {/* Add to Cart Section */}
              <div style={{ 
                borderRadius: '12px', 
                padding: '30px',
                boxShadow: '0 4px 12px rgba(0, 0, 0, 0.05)',
                border: '1px solid #e5e7eb',
                backgroundColor: 'white',
                marginTop: '24px'
              }}>
                {!modelData ? (
                  <div>
                    <h2 style={{ 
                      fontSize: '22px', 
                      fontWeight: 'bold', 
                      marginBottom: '16px',
                      color: '#0ea5e9'
                    }}>Prisberegning</h2>
                    <p style={{ color: '#6b7280' }}>Last opp en fil for å få et prisoverslag.</p>
                  </div>
                ) : loading ? (
                  <div style={{ 
                    display: 'flex', 
                    alignItems: 'center', 
                    justifyContent: 'center', 
                    padding: '24px 0'
                  }}>
                    <FaSpinner style={{ 
                      animation: 'spin 1s linear infinite',
                      marginRight: '8px',
                      color: '#0284c7'
                    }} />
                    <span>Beregner pris...</span>
                  </div>
                ) : (
                  <div>
                    <div style={{ 
                      padding: '30px 0', 
                      margin: '0 -30px',
                      background: 'linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%)',
                      borderRadius: '12px',
                      textAlign: 'center'
                    }}>
                      <div style={{ fontSize: '16px', fontWeight: '500', color: '#0284c7', marginBottom: '8px' }}>
                        Total pris
                      </div>
                      <div style={{ 
                        fontSize: '36px', 
                        fontWeight: '800', 
                        color: '#0284c7',
                        display: 'flex',
                        alignItems: 'baseline',
                        justifyContent: 'center',
                        gap: '4px'
                      }}>
                        <span style={{ fontSize: '24px' }}>kr</span>
                        <span>{(calculatePrice() * 10.5).toFixed(2)}</span>
                      </div>
                      <p style={{ fontSize: '14px', color: '#6b7280', marginTop: '8px' }}>
                        Inkluderer materialer, utskriftstid og behandling
                      </p>
                    </div>
                    
                    <button 
                      onClick={handleAddToCart}
                      disabled={loading}
                      style={{
                        width: '100%',
                        padding: '16px',
                        marginTop: '24px',
                        backgroundColor: '#0ea5e9',
                        color: 'white',
                        border: 'none',
                        borderRadius: '8px',
                        fontSize: '16px',
                        fontWeight: '600',
                        cursor: 'pointer',
                        transition: 'all 0.2s ease',
                        boxShadow: '0 4px 12px rgba(14, 165, 233, 0.3)',
                        ':hover': {
                          backgroundColor: '#0284c7'
                        }
                      }}
                    >
                      Legg til i handlekurv
                    </button>
                  </div>
                )}
              </div>
            </div>
          </div>
        </div>
      </main>
      
      <div style={{
        backgroundColor: '#1e293b',
        padding: '24px 0',
        color: 'white',
      }}>
        <div style={{
          maxWidth: '1200px',
          margin: '0 auto',
          padding: '0 24px',
          display: 'flex',
          justifyContent: 'space-between',
          alignItems: 'center'
        }}>
          <div style={{
            display: 'flex',
            gap: '20px'
          }}>
            <a href="#" style={{ color: '#94a3b8', textDecoration: 'none', fontSize: '14px' }}>About Us</a>
            <a href="#" style={{ color: '#94a3b8', textDecoration: 'none', fontSize: '14px' }}>Contact</a>
            <a href="#" style={{ color: '#94a3b8', textDecoration: 'none', fontSize: '14px' }}>Terms & Conditions</a>
            <a href="#" style={{ color: '#94a3b8', textDecoration: 'none', fontSize: '14px' }}>Privacy Policy</a>
          </div>
          
          <p style={{ color: '#94a3b8', fontSize: '14px', margin: 0 }}>
            © {new Date().getFullYear()} Laserkongen. All rights reserved.
          </p>
        </div>
      </div>
      
      <style jsx global>{`
        @keyframes spin {
          0% { transform: rotate(0deg); }
          100% { transform: rotate(360deg); }
        }
      `}</style>
    </div>
  );
}